<!DOCTYPE html>

<html>

<head>
    <title>LastHomework_COMP392_Jason_Pearson - Apr 27, 2018</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/ColladaLoader.js"></script>

    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output">
    </div>
    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>

    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.
        function init() {

            var stats = initStats();

            // create a scene, that will hold all our elements such as objects, cameras and lights.
            var scene = new THREE.Scene();

            // create a camera, which defines where we're looking at.
            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

            // create a render and set the size
            var webGLRenderer = new THREE.WebGLRenderer();
            webGLRenderer.setClearColor(new THREE.Color(0xcccccc, 1.0));
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
            webGLRenderer.shadowMapEnabled = true;
            //webGLRenderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

            // position and point the camera to the center of the scene
            camera.position.x = 120;
            camera.position.y = 350;
            camera.position.z = 50;
            camera.lookAt(new THREE.Vector3(55, 25, 0));

            // add spotlight for the shadows
            var spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(150, 150, 150);
            spotLight.intensity = 2;
            spotLight.castShadow = true; // default false

            scene.add(spotLight);
            //Create a helper for the shadow camera (optional)
            var spotLightHelper = new THREE.SpotLightHelper(spotLight);
            scene.add(spotLightHelper);
            //Set up shadow properties for the light
            //light.shadow.mapSize.width = 512; // default
            //light.shadow.mapSize.height = 512; // default
            //light.shadow.camera.near = 0.5; // default
            //light.shadow.camera.far = 500 // default

            // add the output of the renderer to the html element
            document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
            var plane;

            var controls = new function() {
                this.spotLightColor = "#ffffff";
                this.spotLightWidth = -436;
                this.spotLightHeight = 183;
                this.spotLightLength = 150;
                //this.spotLightRadius = 2;
                this.cameraPX = 107;
                this.cameraPY = 500;
                this.cameraPZ = -12;
                this.modelPX = -45;
                this.modelPY = 20;
                this.modelPZ = 31;
                //this.modelRX = 0;
                this.modelRY = 0;
                this.modelRZ = 5;
                this.planePX = 42;
                this.planePY = 31;
                this.planePZ = 9;
                //this.planeRX = 0;
                this.planeRY = 0;
                this.planeRZ = 0;

                //Morph Influence/ Update Function
                /*this.influence = 0;
                this.influence1 = 0;


                this.update = function() {
                    cube.morphTargetInfluences[0] = controls.influence;
                    cube.morphTargetInfluences[1] = controls.influence1;

                };*/
            };

            var gui = new dat.GUI();

            gui.addColor(controls, 'spotLightColor').onChange((c) => {
                spotLight.color = new THREE.Color(c);
            });
            gui.add(controls, 'spotLightWidth', -1000, 1000).onChange(() => {
                spotLight.position.x = controls.spotLightWidth;
            });
            gui.add(controls, 'spotLightHeight', -1000, 1000).onChange(() => {
                spotLight.position.y = controls.spotLightHeight;
            });
            gui.add(controls, 'spotLightLength', -1000, 1000).onChange(() => {
                spotLight.position.z = controls.spotLightLength;
            });

            //Camera
            gui.add(controls, 'cameraPX', -1000, 1000)
            gui.add(controls, 'cameraPY', -1000, 1000)
            gui.add(controls, 'cameraPZ', -1000, 1000)
                //Model Controls
            gui.add(controls, 'modelPX', -500, 500).onChange(() => {
                mesh.position.x = controls.modelPX;
            });
            gui.add(controls, 'modelPY', -500, 500).onChange(() => {
                mesh.position.y = controls.modelPY;
            });
            gui.add(controls, 'modelPZ', -500, 500).onChange(() => {
                mesh.position.z = controls.modelPZ;
            });
            /*gui.add(controls, 'modelRX', 0, 1).onChange(() => {
                mesh.rotation.x = controls.modelRX;
            });*/
            gui.add(controls, 'modelRY', -10, 10).onChange(() => {
                mesh.rotation.y = controls.modelRY;
            });
            gui.add(controls, 'modelRZ', -10, 10).onChange(() => {
                mesh.rotation.z = controls.modelRZ;
            });
            //Plane Controls
            gui.add(controls, 'planePX', -500, 500).onChange(() => {
                plane.position.x = controls.planePX;
            });
            gui.add(controls, 'planePY', -500, 500).onChange(() => {
                plane.position.y = controls.planePY;
            });
            gui.add(controls, 'planePZ', -500, 500).onChange(() => {
                plane.position.z = controls.planePZ;
            });
            /*gui.add(controls, 'planeRX', 0, 360).onChange(() => {
                plane.rotation.x = controls.planeRX;
            });*/
            gui.add(controls, 'planeRY', -10, 10).onChange(() => {
                plane.rotation.y = controls.planeRY;
            });
            gui.add(controls, 'planeRZ', -10, 10).onChange(() => {
                plane.rotation.z = controls.planeRZ;
            });
            //Morph Control
            /*gui.add(controls, 'influence', 0, 1).step(0.01).onChange(function(value) {
                cube.morphTargetInfluences[0] = value;
            });
            gui.add(controls, 'Morph2', 0, 1).onChange(controls.update);*/


            // model from https://clara.io/view/1a5cdc65-d1e2-4e7d-998f-a75288fbe3b4
            var loader = new THREE.ColladaLoader();

            var mesh;

            //Morph Target -----
            /*var cubeTarget = new THREE.BoxGeometry(8, 2, 8);
            var cubeTarget1 = new THREE.BoxGeometry(2, 10, 2);
            var cubeGeometry = new THREE.BoxGeometry(50, 50, 50);
            var cubeMaterial = new THREE.MeshLambertMaterial({
                morphTargets: true,
                color: 0xff0000
            });*/

            /*for (var i = 0; i < 8; i++) {

                var vertices = [];

                for (var v = 0; v < geometry.vertices.length; v++) {

                    vertices.push(cubeGeometry.vertices[v].clone());

                    if (v === i) {

                        vertices[vertices.length - 1].x *= 2;
                        vertices[vertices.length - 1].y *= 2;
                        vertices[vertices.length - 1].z *= 2;

                    }

                }

                cubeGeometry.morphTargets.push({
                    name: "target" + i,
                    vertices: vertices
                });

            }*/


            /*cubeGeometry.morphTargets[0] = {
                name: 't1',
                vertices: cubeTarget.vertices
            };
            cubeGeometry.morphTargets[1] = {
                name: 't2',
                vertices: cubeTarget1.vertices
            };
            cubeGeometry.computeMorphNormals();
            var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);*/

            loader.load("../assets/models/dae/fluffy-cloud-mane.dae", function(result) {
                mesh = result.scene.children[0].clone();
                var meshGeo = mesh.clone().geometry;
                //mesh.vertices.update = true;
                //mesh.geometry.normalsNeedUpdate = true;
                //var geo = mesh.geometry;
                var mat = new THREE.MeshLambertMaterial({
                    morphTargets: true
                        //color: 0xff0000
                });
                //mesh = new THREE.Mesh(meshGeo, cubeMaterial);
                //mesh.geometry.Set(cubeGeometry);
                //mesh.material = mat;
                //mesh.material.set(mat);

                //mesh.MeshLambertMaterial.morphTargets = true;
                mesh.scale.set(4, 4, 4);
                mesh.rotation.x = -Math.PI / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = false;

                //Morph Target Array set
                /*mesh.morphTargets[0] = {
                    name: 't1',
                    vertices: cubeTarget.vertices
                };*/
                /*mesh.geometry.morphTargets[1] = {
                    name: 't1',
                    vertices: cubeTarget1.vertices
                };*/

                //mesh.geometry.computeMorphNormals(); //Morph NORMALS

                scene.add(mesh);
            });

            /*cube.position.x = 45;
            cube.position.y = 20;
            cube.position.z = 50;
            scene.add(cube);*/


            plane = createMesh(new THREE.PlaneGeometry(20, 20, 2, 2));
            plane.scale.x = 100;
            plane.scale.y = 100;
            plane.rotation.x = -Math.PI * .5;
            plane.receiveShadow = true;

            scene.add(plane);


            //plane.receiveShadow = true;

            //var loader = new THREE.ColladaLoader();
            /*loader.options.convertUpAxis = true;
            loader.load("../assets/models/dae/army-man-dae.dae", function colladaReady(collada) {

                model = collada.scene;
                model_geometry = collada.scene.children[0].geometry;
                model_material = collada.scene.children[0].material;

                model.scale.set(10.0, 10.0, 10.0);
                model.updateMatrix();
            });*/

            render();

            function createMesh(geom) {

                // assign two materials
                //            var meshMaterial = new THREE.MeshLambertMaterial({color: 0xff5555});
                //            var meshMaterial = new THREE.MeshNormalMaterial();
                var meshMaterial = new THREE.MeshPhongMaterial({
                    specular: 0xffffff,
                    color: 0xeeffff,
                    shininess: 100,
                    metal: true
                });
                //            meshMaterial.side=THREE.DoubleSide;
                // create a multimaterial
                var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]);

                return plane;
            }

            function render() {
                stats.update();

                camera.position.x = controls.cameraPX;
                camera.position.y = controls.cameraPY;
                camera.position.z = controls.cameraPZ;
                //mesh.material.Set(cubeMaterial);

                //mesh.scale.set(controls.modelPX, controls.modelPY, controls.modelPZ);
                //mesh.position.x = controls.modelPX;
                //mesh.position.y = controls.modelPY;
                //mesh.position.z = controls.modelPZ;

                // render using requestAnimationFrame
                requestAnimationFrame(render);
                webGLRenderer.render(scene, camera);
            }

            function initStats() {

                var stats = new Stats();
                stats.setMode(0); // 0: fps, 1: ms

                // Align top-left
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';

                document.getElementById("Stats-output").appendChild(stats.domElement);

                return stats;
            }
        }
        window.onload = init;
    </script>
</body>

</html>