<!DOCTYPE html>

<html>

<head>
    <title>LastHomework_COMP392_Jason_Pearson - Apr 27, 2018</title>
    <script type="text/javascript" src="../libs/three.js"></script>
    <script type="text/javascript" src="../libs/ColladaLoader.js"></script>
	<script type="text/javascript" src="../libs/OrbitControls.js"></script>

    <script type="text/javascript" src="../libs/stats.js"></script>
    <script type="text/javascript" src="../libs/dat.gui.js"></script>
    <script type="text/javascript" src="../libs/Projector.js"></script>    
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output">
    </div>
    <!-- Div which will hold the Output -->
    <div id="WebGL-output">
    </div>

    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">

    //Global Variables
   var stats, scene,webGLRenderer, camera, projector;
   var spotLight, spotLightHelper, shadowCameraHelper;
        // once everything is loaded, we run our Three.js stuff.
        function init() {

             stats = initStats();

            // create a scene, that will hold all our elements such as objects, cameras and lights.
             scene = new THREE.Scene();

            // create a camera, which defines where we're looking at.
             camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

            // create a render and set the size
            webGLRenderer = new THREE.WebGLRenderer();
            webGLRenderer.setClearColor(new THREE.Color(0xcccccc, 1.0));
            webGLRenderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
            webGLRenderer.shadowMapEnabled = true;
            webGLRenderer.shadowMapType = THREE.PCFSoftShadowMap;
//renderer.gammaInput = true;
//			renderer.gammaOutput = true;
            //webGLRenderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

            // position and point the camera to the center of the scene
            camera.position.x = 120;
            camera.position.y = 350;
            camera.position.z = 50;
            camera.lookAt(new THREE.Vector3(55, 25, 0));

            //create a projector for Mouse EventHandlers
            var projector = new THREE.Projector();
            //document.addEventListener('mousedown', onDocumentMouseDown, true);
            //document.addEventListener('mousemove', onDocumentMouseMove, false);
            //document.addEventListener('mouseover', onDocumentMouseOver, false);

            // add spotlight for the shadows
            spotLight = new THREE.SpotLight(0xffffff);
            spotLight.position.set(-46, 279, 41);
            spotLight.intensity = 5;
            spotLight.angle = Math.PI / 4;
				spotLight.penumbra = 0.05;
				spotLight.decay = 2;
				spotLight.distance = 200;

            spotLight.castShadow = true; // default false
spotLight.shadowDarkness = 1;
spotLight.shadowCameraVisible = true;

//spotLight.shadowMapSize.width = 1024;
				//spotLight.shadowMapSize.height = 1024;
				//spotLight.shadowCamera.near = 10;
				//spotLight.shadowCamera.far = 200;
            scene.add(spotLight);
            //Create a helper for the shadow camera (optional)
            spotLightHelper = new THREE.SpotLightHelper(spotLight);
            scene.add(spotLightHelper);

            var ambient = new THREE.AmbientLight( 0xaaaaaa, 0.1 );
				scene.add( ambient );
///#region LightShadows
            //Set up shadow properties for the light
            //light.shadow.mapSize.width = 512; // default
            //light.shadow.mapSize.height = 512; // default
            //light.shadow.camera.near = 0.5; // default
            //light.shadow.camera.far = 500 // default
///#endregion
            // add the output of the renderer to the html element
           // document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);
            var plane;
            var step = 0;
            var Flatten = true;
/*
                var orbControls = new THREE.OrbitControls(camera, webGLRenderer.domElement);
				orbControls.addEventListener( 'change', render );
				orbControls.minDistance = 20;
				orbControls.maxDistance = 500;
				orbControls.enablePan = false;
*/
            var controls = new function() {
                //this.keyframe = 0;
                this.Flatten = true;
                
                this.spotLightColor = "#ffffff";
                this.spotLightWidth = -46;
                this.spotLightHeight = 279;
                this.spotLightLength = 41;
                //this.spotLightRadius = 2;
                this.cameraPX = 107;
                this.cameraPY = 500;
                this.cameraPZ = -12;
                this.modelPX = -45;
                this.modelPY = 20;
                this.modelPZ = 31;
                //this.modelRX = 0;
                this.modelRY = 0;
                this.modelRZ = 5;
                this.planePX = 42;
                this.planePY = 31;
                this.planePZ = 9;
                //this.planeRX = 0;
                this.planeRY = 0;
                this.planeRZ = 0;
///#region MorphViaCube_Controls.Variables
                //Morph Influence/ Update Function
                /*this.influence = 0;
                this.influence1 = 0;


                this.update = function() {
                    cube.morphTargetInfluences[0] = controls.influence;
                    cube.morphTargetInfluences[1] = controls.influence1;
///#endregion
                };*/
            };

            var gui = new dat.GUI();

            gui.addColor(controls, 'spotLightColor').onChange((c) => {
                spotLight.color = new THREE.Color(c);
            });
            gui.add(controls, 'spotLightWidth', -1000, 1000).onChange(() => {
                spotLight.position.x = controls.spotLightWidth;
            });
            gui.add(controls, 'spotLightHeight', -1000, 1000).onChange(() => {
                spotLight.position.y = controls.spotLightHeight;
            });
            gui.add(controls, 'spotLightLength', -1000, 1000).onChange(() => {
                spotLight.position.z = controls.spotLightLength;
            });

            //Camera
            gui.add(controls, 'cameraPX', -1000, 1000)
            gui.add(controls, 'cameraPY', -2000, 2000)
            gui.add(controls, 'cameraPZ', -1000, 1000)
                //Model Controls
            gui.add(controls, 'modelPX', -500, 500).onChange(() => {
                mesh.position.x = controls.modelPX;
            });
            gui.add(controls, 'modelPY', -500, 500).onChange(() => {
                mesh.position.y = controls.modelPY;
            });
            gui.add(controls, 'modelPZ', -500, 500).onChange(() => {
                mesh.position.z = controls.modelPZ;
            });
            /*gui.add(controls, 'modelRX', 0, 1).onChange(() => {
                mesh.rotation.x = controls.modelRX;
            });*/
            gui.add(controls, 'modelRY', -10, 10).onChange(() => {
                mesh.rotation.y = controls.modelRY;
            });
            gui.add(controls, 'modelRZ', -10, 10).onChange(() => {
                mesh.rotation.z = controls.modelRZ;
            });
            //Plane Controls
            gui.add(controls, 'planePX', -500, 500).onChange(() => {
                plane.position.x = controls.planePX;
            });
            gui.add(controls, 'planePY', -500, 500).onChange(() => {
                plane.position.y = controls.planePY;
            });
            gui.add(controls, 'planePZ', -500, 500).onChange(() => {
                plane.position.z = controls.planePZ;
            });
            /*gui.add(controls, 'planeRX', 0, 360).onChange(() => {
                plane.rotation.x = controls.planeRX;
            });*/
            gui.add(controls, 'planeRY', -10, 10).onChange(() => {
                plane.rotation.y = controls.planeRY;
            });
            gui.add(controls, 'planeRZ', -10, 10).onChange(() => {
                plane.rotation.z = controls.planeRZ;
            });
            gui.add(controls, 'Flatten').onChange((toggle) => {
                //document.addEventListener('mousedown', onDocumentMouseDown, toggle);
                });
                
///#region MorphViaCube_Controls           //Morph Control
            /*gui.add(controls, 'influence', 0, 1).step(0.01).onChange(function(value) {
                cube.morphTargetInfluences[0] = value;
            });
            gui.add(controls, 'Morph2', 0, 1).onChange(controls.update);*/
///#endregion

            // model from https://clara.io/view/1a5cdc65-d1e2-4e7d-998f-a75288fbe3b4
            //var loader = new THREE.ColladaLoader();

            //var mesh;
            
///#region MorphViaCube_Variables_Vertices
            //Morph Target -----
            /*var cubeTarget = new THREE.BoxGeometry(8, 2, 8);
            var cubeTarget1 = new THREE.BoxGeometry(2, 10, 2);
            var cubeGeometry = new THREE.BoxGeometry(50, 50, 50);
            var cubeMaterial = new THREE.MeshLambertMaterial({
                morphTargets: true,
                color: 0xff0000
            });*/

            /*for (var i = 0; i < 8; i++) {

                var vertices = [];

                for (var v = 0; v < geometry.vertices.length; v++) {

                    vertices.push(cubeGeometry.vertices[v].clone());

                    if (v === i) {

                        vertices[vertices.length - 1].x *= 2;
                        vertices[vertices.length - 1].y *= 2;
                        vertices[vertices.length - 1].z *= 2;

                    }

                }

                cubeGeometry.morphTargets.push({
                    name: "target" + i,
                    vertices: vertices
                });

            }*/


            /*cubeGeometry.morphTargets[0] = {
                name: 't1',
                vertices: cubeTarget.vertices
            };
            cubeGeometry.morphTargets[1] = {
                name: 't2',
                vertices: cubeTarget1.vertices
            };
            cubeGeometry.computeMorphNormals();
            var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);*/
///#endregion

            /*loader.load("../assets/models/dae/n64.dae", function(result) {
                mesh = result.scene.children[0].clone();
                var meshGeo = mesh.clone().geometry;
                //mesh.vertices.update = true;
                //mesh.geometry.normalsNeedUpdate = true;
                //var geo = mesh.geometry;
               var mat = new THREE.MeshLambertMaterial(
                    {
                        morphTargets: true,
                        //vertexColors: THREE.FaceColors
                    });                
                //mesh = new THREE.Mesh(meshGeo, cubeMaterial);
                //mesh.geometry.Set(cubeGeometry);
                //mesh.material = mat;
                //mesh.material.set(mat);

                //mesh.MeshLambertMaterial.morphTargets = true;          
               mesh.scale.set(4, 4, 4);
                mesh.rotation.x = -Math.PI / 2;
                mesh.castShadow = true;
                 mesh.receiveShadow = false;
               
                //Morph Target Array set
                /*mesh.morphTargets[0] = {
                    name: 't1',
                    vertices: cubeTarget.vertices
                };*/
                /*mesh.geometry.morphTargets[1] = {
                    name: 't1',
                    vertices: cubeTarget1.vertices
                };*/

                //mesh.geometry.computeMorphNormals(); //Morph NORMALS

  //            scene.add(mesh);
   //         });
            
///#region MorphViaCube_Position
            /*cube.position.x = 45;
            cube.position.y = 20;
            cube.position.z = 50;
            scene.add(cube);*/
///#endregion

/*var loader = new THREE.JSONLoader();
loader.load("../assets/models/n64.json", function ( geometry, materials ) {
    var mesh = new THREE.Mesh(geometry.geometry, new THREE.MeshLambertMaterial(materials) );
    mesh.scale.set(15, 15, 15);
                mesh.position.x = -45;
                mesh.position.y = 20;
                mesh.position.z = 31;
                mesh.rotation.x = -Math.PI / 2;
                mesh.castShadow = true;
                 mesh.receiveShadow = false;
    scene.add(mesh);
    console.log("loaded");

});*/

/*var objectLoader = new THREE.ObjectLoader();
objectLoader.load("../assets/models/json/n64.json", function (obj) {
obj.scale.set(10, 10, 10);
                obj.rotation.x = -Math.PI / 2;
                obj.castShadow = true;
                 obj.receiveShadow = false;
                 obj.position.x = -45;
                obj.position.y = 20;
                obj.position.z = 31;
scene.add(obj);
} );*/

/*var loader = new THREE.JSONLoader();
        loader.load('../assets/models/horse.js', function (geometry, mat) {

            var mat = new THREE.MeshLambertMaterial(
                    {
                        morphTargets: true,
                        vertexColors: THREE.FaceColors
                    });
        });

            plane = createMesh(new THREE.PlaneGeometry(20, 20, 2, 2));
            plane.scale.x = 100;
            plane.scale.y = 100;
            plane.rotation.x = -Math.PI * .5;
            plane.receiveShadow = true;

            scene.add(plane);*/
        
///#region LoadingCollada_Reference
            //var loader = new THREE.ColladaLoader();
            /*loader.options.convertUpAxis = true;
            loader.load("../assets/models/dae/army-man-dae.dae", function colladaReady(collada) {

                model = collada.scene;
                model_geometry = collada.scene.children[0].geometry;
                model_material = collada.scene.children[0].material;

                model.scale.set(10.0, 10.0, 10.0);
                model.updateMatrix();
            });*/
///#endregion
            render();

            function createMesh(geom) {

                // assign two materials
                //            var meshMaterial = new THREE.MeshLambertMaterial({color: 0xff5555});
                //            var meshMaterial = new THREE.MeshNormalMaterial();
                var meshMaterial = new THREE.MeshLambertMaterial({
                    specular: 0xffffff,
                    color: 0xeeffff,
                    shininess: 100,
                    metal: true
                });
                //            meshMaterial.side=THREE.DoubleSide;
                // create a multimaterial
                var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]);

                return plane;
            }
/*function onDocumentMouseDown(event) {
    this.Flatten^=true;
            if(this.Flatten == 1)
            {
                    console.log("Flat");

            var scaleY = Math.abs(Math.cos(0.1 / 5));
            mesh.scale.set(4, 0.2, 4);
            }
            else{
                //this.Flatten = true;
                    console.log("Restore");
            mesh.scale.set(4, 4, 4);
            }

}*/

/*function onResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

*/
            function render() {
                stats.update();

                camera.position.x = controls.cameraPX;
                camera.position.y = controls.cameraPY;
                camera.position.z = controls.cameraPZ;
///#region Render_Controls
                //mesh.material.Set(cubeMaterial);

                //mesh.scale.set(controls.modelPX, controls.modelPY, controls.modelPZ);
                //mesh.position.x = controls.modelPX;
                //mesh.position.y = controls.modelPY;
                //mesh.position.z = controls.modelPZ;

                // render using requestAnimationFrame
                //lightHelper.update();
				//shadowCameraHelper.update();

                requestAnimationFrame(render);
                webGLRenderer.render(scene, camera);
            }
///#endregion
            function initStats() {

                var stats = new Stats();
                stats.setMode(0); // 0: fps, 1: ms

                // Align top-left
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.left = '0px';
                stats.domElement.style.top = '0px';

                document.getElementById("Stats-output").appendChild(stats.domElement);

                return stats;
            }
        }
        window.onload = init;
    </script>
</body>

</html>